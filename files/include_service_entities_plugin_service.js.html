<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>include\service\entities\plugin_service.js - PencilBlue</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="http://pencilblue.org/img/pb_logo.png" title="PencilBlue"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.1.0</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="../classes/AdminNavigation.html">AdminNavigation</a></li>
            
                <li><a href="../classes/AdminSubnavService.html">AdminSubnavService</a></li>
            
                <li><a href="../classes/ArticleService.html">ArticleService</a></li>
            
                <li><a href="../classes/CacheEntityService.html">CacheEntityService</a></li>
            
                <li><a href="../classes/CacheFactory.html">CacheFactory</a></li>
            
                <li><a href="../classes/ClientJS.html">ClientJS</a></li>
            
                <li><a href="../classes/CommentService.html">CommentService</a></li>
            
                <li><a href="../classes/ContentService.html">ContentService</a></li>
            
                <li><a href="../classes/DAO.html">DAO</a></li>
            
                <li><a href="../classes/DBEntityService.html">DBEntityService</a></li>
            
                <li><a href="../classes/DBManager.html">DBManager</a></li>
            
                <li><a href="../classes/DocumentCreator.html">DocumentCreator</a></li>
            
                <li><a href="../classes/EmailService.html">EmailService</a></li>
            
                <li><a href="../classes/FSEntityService.html">FSEntityService</a></li>
            
                <li><a href="../classes/JSONFSEntityService.html">JSONFSEntityService</a></li>
            
                <li><a href="../classes/Localization.html">Localization</a></li>
            
                <li><a href="../classes/MediaLoader.html">MediaLoader</a></li>
            
                <li><a href="../classes/MediaService.html">MediaService</a></li>
            
                <li><a href="../classes/MemoryEntityService.html">MemoryEntityService</a></li>
            
                <li><a href="../classes/MongoSessionStore.html">MongoSessionStore</a></li>
            
                <li><a href="../classes/PBError.html">PBError</a></li>
            
                <li><a href="../classes/PluginService.html">PluginService</a></li>
            
                <li><a href="../classes/ReadOnlySimpleLayeredService.html">ReadOnlySimpleLayeredService</a></li>
            
                <li><a href="../classes/RedisSessionStore.html">RedisSessionStore</a></li>
            
                <li><a href="../classes/SecurityService.html">SecurityService</a></li>
            
                <li><a href="../classes/SessionHandler.html">SessionHandler</a></li>
            
                <li><a href="../classes/SimpleLayeredService.html">SimpleLayeredService</a></li>
            
                <li><a href="../classes/TemplateService.html">TemplateService</a></li>
            
                <li><a href="../classes/TopMenuService.html">TopMenuService</a></li>
            
                <li><a href="../classes/UrlService.html">UrlService</a></li>
            
                <li><a href="../classes/UserService.html">UserService</a></li>
            
                <li><a href="../classes/Util.html">Util</a></li>
            
                <li><a href="../classes/ValidationService.html">ValidationService</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="../modules/Admin.html">Admin</a></li>
            
                <li><a href="../modules/Database.html">Database</a></li>
            
                <li><a href="../modules/Entities.html">Entities</a></li>
            
                <li><a href="../modules/ErrorSuccess.html">ErrorSuccess</a></li>
            
                <li><a href="../modules/Model.html">Model</a></li>
            
                <li><a href="../modules/Security.html">Security</a></li>
            
                <li><a href="../modules/Services.html">Services</a></li>
            
                <li><a href="../modules/Session.html">Session</a></li>
            
                <li><a href="../modules/Storage.html">Storage</a></li>
            
                <li><a href="../modules/Theme.html">Theme</a></li>
            
                <li><a href="../modules/Validation.html">Validation</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: include\service\entities\plugin_service.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/**
 * PluginService - Provides functions for interacting with plugins.
 * Install/uninstall, setting retrieval, plugin retrieval, etc.
 *
 * @class PluginService
 * @constructor
 * @module Services
 * @submodule Entities
 */
function PluginService(){

	//construct settings services
	var caching = pb.config.plugins.caching;
	this.pluginSettingsService = PluginService.genSettingsService(&#x27;plugin_settings&#x27;, caching.useMemory, caching.useCache, &#x27;PluginSettingService&#x27;);
	this.themeSettingsService  = PluginService.genSettingsService(&#x27;theme_settings&#x27;, caching.useMemory, caching.useCache, &#x27;ThemeSettingService&#x27;);
}

//constants
var PLUGINS_DIR       = path.join(DOCUMENT_ROOT, &#x27;plugins&#x27;);
var DETAILS_FILE_NAME = &#x27;details.json&#x27;;
var PUBLIC_DIR_NAME   = &#x27;public&#x27;;

//statics
var ACTIVE_PLUGINS = {};

PluginService.prototype.getActiveIcon = function(cb) {
	pb.settings.get(&#x27;active_theme&#x27;, function(err, theme) {
		if (ACTIVE_PLUGINS[theme] &amp;&amp; ACTIVE_PLUGINS[theme].icon) {
			cb(err, ACTIVE_PLUGINS[theme].icon);
		}
		else {
			cb(err, &#x27;/favicon.ico&#x27;);
		}
	});
};

/**
 * Retrieves the names of the active plugins for this instance
 * @method getActivePluginNames
 * @return {array} An array that contain the names of the plugins that
 * initialized successfully within this instance.
 */
PluginService.prototype.getActivePluginNames = function() {
	return Object.keys(ACTIVE_PLUGINS);
};

/**
 * Retrieves a single setting for the specified plugin.
 *
 * @method getSetting
 * @param {string} settingName The name of the setting to retrieve
 * @param {string} pluginName The name of the plugin who owns the setting
 * @param {function} cb A callback that provides two parameters: cb(error, settingValue).
 * Null is returned if the setting does not exist or the specified plugin is not
 * installed.
 */
PluginService.prototype.getSetting = function(settingName, pluginName, cb) {
	this.getSettings(pluginName, function(err, settings) {
		if (util.isError(err)) {
			cb(err, null);
			return;
		}

        var val = null;
        if (util.isArray(settings)) {
            for (var i = 0; i &lt; settings.length; i++) {
                if (settingName === settings[i].name) {
                    val = settings[i].value;
                    break;
                }
            }
        }
		cb(err, val);
	});
};

/**
 * Retrieves all of the settings for the specfied plugin.
 *
 * @method getSettings
 * @param pluginName The name of the plugin who&#x27;s settings are being requested
 * @param cb A callback that provides two parameters: cb(error, settings).
 * Null is provided in the event that the plugin is not installed.
 */
PluginService.prototype.getSettings = function(pluginName, cb) {
	this.pluginSettingsService.get(pluginName, cb);
};

/**
 * Replaces a single setting for the specified plugin
 *
 * @method setSetting
 * @param name The name of the setting to change
 * @param value The new value for the setting
 * @param pluginName The plugin who&#x27;s setting is being changed.
 * @param cb A callback that provides two parameters: cb(error, TRUE/FALSE).
 * TRUE if the setting was persisted successfully, FALSE if not.
 */
PluginService.prototype.setSetting = function(name, value, pluginName, cb) {
	var self = this;

	//error checking
	if (!PluginService.validateSettingValue(value)) {
		cb(new Error(&quot;PluginService: The setting value is required when modifing a theme setting&quot;), false);
	}
	if (!pb.validation.validateNonEmptyStr(name, true)) {
		cb(new Error(&quot;PluginService: The setting name is required when modifing a theme setting&quot;), false);
	}

	//retrieve the settings to modify
	this.getSettings(pluginName, function(err, settings) {
		if (util.isError(err) || !settings) {
			cb(err, false);
			return;
		}

		var wasFound = false;
        for (var i = 0; i &lt; settings.length; i++) {
            if (name === settings[i].name) {
                settings[i].value = value;
                wasFound = true;
                break;
            }
        }
        if (!wasFound) {
            settings.push({
                name: name,
                value: value
            });
        }
		self.setSettings(settings, pluginName, cb);
	});
};

/**
 * Replaces the settings for the specified plugin.
 *
 * @method setSettings
 * @param settings The settings object to be validated and persisted
 * @param pluginName The name of the plugin who&#x27;s settings are being represented
 * @param cb A callback that provides two parameters: cb(error, TRUE/FALSE).
 * TRUE if the settings were persisted successfully, FALSE if not.
 */
PluginService.prototype.setSettings = function(settings, pluginName, cb) {
	var self = this;

	//error checking
	if (!settings) {
		cb(new Error(&quot;PluginService: The settings object is required when making changes to plugin settings&quot;), false);
		return;
	}
	if (!pluginName) {
		cb(new Error(&quot;PluginService: The plugin name is required when making changes to plugin settings&quot;), false);
		return;
	}

	this.isInstalled(pluginName, function(err, isInstalled) {
		if (util.isError(err) || !isInstalled) {
			cb(err, false);
			return;
		}

		self.pluginSettingsService.set(pluginName, settings, function(err, result) {
			cb(err, !util.isError(err) &amp;&amp; result);
		});
	});
};

/**
 * Replaces a single theme setting for the specified plugin
 *
 * @method setThemeSetting
 * @param name The name of the setting to change
 * @param value The new value for the setting
 * @param pluginName The plugin who&#x27;s setting is being changed.
 * @param cb A callback that provides two parameters: cb(error, TRUE/FALSE).
 * TRUE if the setting was persisted successfully, FALSE if not.
 */
PluginService.prototype.setThemeSetting = function(name, value, pluginName, cb) {
	var self = this;

	//error checking
	if (!PluginService.validateSettingValue(value)) {
		cb(new Error(&quot;PluginService: The setting value is required when modifing a theme setting&quot;), false);
	}
	if (!pb.validation.validateNonEmptyStr(name, true)) {
		cb(new Error(&quot;PluginService: The setting name is required when modifing a theme setting&quot;), false);
	}

	//retrieve the settings to modify
	this.getThemeSettings(pluginName, function(err, settings) {
		if (util.isError(err) || !settings) {
			cb(err, false);
			return;
		}

        var wasFound = false;
        for (var i = 0; i &lt; settings.length; i++) {
            if (name === settings[i].name) {
                settings[i].value = value;
                wasFound = true;
                break;
            }
        }
        if (!wasFound) {
            settings.push({
                name: name,
                value: value
            });
        }
		self.setThemeSettings(settings, pluginName, cb);
	});
};

/**
 * Replaces the theme settings for the specified plugin.
 *
 * @method setThemeSettings
 * @param settings The settings object to be validated and persisted
 * @param pluginName The uid of the plugin who&#x27;s settings are being represented
 * @param cb A callback that provides two parameters: cb(error, TRUE/FALSE).
 * TRUE if the settings were persisted successfully, FALSE if not.
 */
PluginService.prototype.setThemeSettings = function(settings, pluginName, cb) {
	var self = this;

	//error checking
	if (!settings) {
		cb(new Error(&quot;PluginService: The settings object is required when making changes to theme settings&quot;), false);
		return;
	}
	if (!pluginName) {
		cb(new Error(&quot;PluginService: The plugin name is required when making changes to theme settings&quot;), false);
		return;
	}

	this.isInstalled(pluginName, function(err, isInstalled) {
		if (util.isError(err) || !isInstalled) {
			cb(err, false);
			return;
		}

		self.themeSettingsService.set(pluginName, settings, function(err, result) {
			cb(err, !util.isError(err) &amp;&amp; result);
		});
	});
};

/**
 * Retrieves a single theme setting value.
 *
 * @method getThemeSetting
 * @param settingName The uid of the setting
 * @param pluginName The plugin to retrieve the setting from
 * @param cb A callback that provides two parameters: cb(error, settingValue)
 */
PluginService.prototype.getThemeSetting = function(settingName, pluginName, cb) {
	this.getThemeSettings(pluginName, function(err, settings) {
		if (util.isError(err)) {
			cb(err, null);
			return;
		}

		var val = null;
        if (util.isArray(settings)) {
            for (var i = 0; i &lt; settings.length; i++) {
                if (settingName === settings[i].name) {
                    val = settings[i].value;
                    break;
                }
            }
        }
		cb(err, val);
	});
};

/**
 * Retrieves the theme settings for the specified plugin
 *
 * @method getThemeSettings
 * @param pluginName The uid of the plugin
 * @param cb A callback that provides two parameters: cb(err, settingsObject)
 */
PluginService.prototype.getThemeSettings = function(pluginName, cb) {
	this.themeSettingsService.get(pluginName, cb);
};

/**
 * Indicates if a plugin by the specified identifier is installed.
 *
 * @method isInstalled
 * @param pluginIdentifer The identifier can either be an ObjectID or the
 * plugin name
 * @param cb A callback that provides two parameters: cb(error, TRUE/FALSE).
 * TRUE if the plugin is installed, FALSE if not.
 */
PluginService.prototype.isInstalled = function(pluginIdentifier, cb) {
	this.getPlugin(pluginIdentifier, function(err, plugin) {
		cb(err, plugin ? true : false);
	});
};

/**
 * Retrieves a plugin descriptor (plugin document)
 *
 * @method getPlugin
 * @param pluginIdentifier The identifier can either be an ObjectID or the
 * plugin name
 * @param cb A callback that provides two parameters: cb(error, plugin).  If the
 * plugin does exist null is provided.
 */
PluginService.prototype.getPlugin = function(pluginIdentifier, cb) {
	var where = {};
	if (pluginIdentifier instanceof ObjectID) {
		where._id = pluginIdentifier;
	}
	else {
		where.uid = pluginIdentifier;
	}
	var dao = new pb.DAO();
	dao.loadByValues(where, &#x27;plugin&#x27;, cb);
};

PluginService.prototype.getPluginsWithThemes = function(cb) {
	var dao = new pb.DAO();
	dao.query(&#x27;plugin&#x27;, {theme: {$exists: true}}).then(function(themes) {
		if (util.isError(themes)) {
			cb(themes, null);
			return;
		}
		cb(null, themes);
	});
};

/**
 * Convenience function to generate a service to handle settings for a plugin.
 *
 * @static
 * @method genSettingsService
 * @param objType The type of object that will be dealt with.  (plugin_settings,
 * theme_settings)
 * @param useMemory {Boolean} Indicates if the generated layered service should
 * use an in memory service.
 * @param useCache {Boolean} Indicates if the generated layered service should
 * use a cache service.
 * @param serviceName The name of the service
 * @return {SimpleLayeredService}
 */
PluginService.genSettingsService = function(objType, useMemory, useCache, serviceName) {

	//add in-memory service
	var services = [];
	if (useMemory){
		services.push(new pb.MemoryEntityService(objType));
	}

	//add cache service
	if (useCache) {
		services.push(new pb.CacheEntityService(objType));
	}

	//always add DB
	services.push(new pb.DBEntityService(objType, &#x27;settings&#x27;, &#x27;plugin_uid&#x27;));
	return new pb.SimpleLayeredService(services, serviceName);
};

/**
 * Loads the settings from a details object and persists them in the DB.  Any
 * existing settings for the plugin are deleted before the new settings are
 * persisted.
 *
 * @method resetSettings
 * @param details The details object to extract the settings from
 * @param cb A callback that provides two parameters: cb(error, TRUE/FALSE).
 * TRUE if the settings were successfully cleared and reloaded. FALSE if not.
 */
PluginService.prototype.resetSettings = function(details, cb) {
	var self = this;

	//retrieve plugin to prove it exists (plus we need the id)
	var pluginName = details.uid;
	this.getPlugin(pluginName, function(err, plugin) {
		if (util.isError(err) || !plugin) {
			cb(err ? err : new Error(&quot;The plugin &quot;+pluginName+&quot;is not installed&quot;), false);
			return;
		}

		//remove any existing settings
		self.pluginSettingsService.purge(pluginName, function (err, result) {
			if (util.isError(err) || !result) {
				cb(err, false);
				return;
			}

			//build the object to persist
			var baseDoc  = {
				plugin_name: plugin.name,
				plugin_uid: plugin.uid,
				plugin_id: plugin._id.toString(),
				settings: details.settings
			};
			var settings = pb.DocumentCreator.create(&#x27;plugin_settings&#x27;, baseDoc);

			//save it
			var dao      = new pb.DAO();
			dao.update(settings).then(function(result) {
				if (util.isError(result)) {
					cb(result, false);
				}
				else {
					cb(null, true);
				}
			});
		});
	});
};

/**
 * Loads the Theme settings from a details object and persists them in the DB.  Any
 * existing theme settings for the plugin are deleted before the new settings
 * are persisted. If the plugin does not have a theme then false is provided in
 * the callback.
 *
 * @method resetThemeSettings
 * @param details The details object to extract the settings from
 * @param cb A callback that provides two parameters: cb(error, TRUE/FALSE).
 * TRUE if the settings were successfully cleared and reloaded. FALSE if not.
 */
PluginService.prototype.resetThemeSettings = function(details, cb) {
	var self = this;

	//error checking
	var pluginName = details.uid;
	if (!details.theme || !details.theme.settings) {
		cb(new Error(&quot;PluginService: Settings are required when attempting to reset a plugin&#x27;s theme settings&quot;), false);
		return;
	}

	//retrieve plugin to prove it exists (plus we need the id)
	this.getPlugin(pluginName, function(err, plugin) {
		if (util.isError(err) || !plugin) {
			cb(err, false);
			return;
		}

		//remove any existing settings
		self.themeSettingsService.purge(pluginName, function (err, result) {
			if (util.isError(err) || !result) {
				cb(err, false);
				return;
			}

			//build the object to persist
			var baseDoc  = {
				plugin_name: plugin.name,
				plugin_uid: plugin.uid,
				plugin_id: plugin._id.toString(),
				settings: details.theme.settings
			};
			var settings = pb.DocumentCreator.create(&#x27;theme_settings&#x27;, baseDoc);

			//save it
			var dao      = new pb.DAO();
			dao.update(settings).then(function(result) {
				if (util.isError(result)) {
					cb(result, false);
				}
				else {
					cb(null, true);
				}
			});
		});
	});
};

PluginService.getPermissionsForRole = function(role) {
	if (!isNaN(role)) {
		role = pb.security.getRoleName(role);
	}

	var perms = {};
	for(var pluginUid in ACTIVE_PLUGINS) {
		var permissions = ACTIVE_PLUGINS[pluginUid].permissions;
		if (permissions) {

			var permsAtLevel = permissions[role];
			if (permsAtLevel) {
				pb.utils.merge(permsAtLevel, perms);
			}
		}
	}
	return perms;
};

PluginService.getActivePluginPublicDir = function(pluginUid) {
	var publicPath = null;
	if (ACTIVE_PLUGINS[pluginUid]) {
		publicPath = ACTIVE_PLUGINS[pluginUid].public_dir;
	}
	return publicPath;
};

PluginService.isActivePlugin = function(uid) {
	return ACTIVE_PLUGINS[uid] !== undefined;
};

PluginService.genPublicPath = function(plugin, relativePathToMedia) {
	if (!pb.utils.isString(plugin) || !pb.utils.isString(relativePathToMedia)) {
		return &#x27;&#x27;;
	}
	return pb.UrlService.urlJoin(&#x27;/public&#x27;, plugin, relativePathToMedia);
};

PluginService.prototype.getActivePlugins = function(cb) {

	var where = {uid: {&#x27;$in&#x27;: this.getActivePluginNames()}};
	var order = {created: pb.DAO.ASC};
	var dao   = new pb.DAO();
	dao.query(&#x27;plugin&#x27;, where, pb.DAO.SELECT_ALL, order).then(function(results) {
		if (util.isError(results)) {
			cb(results, null);
		}
		else {
			cb(null, results);
		}
	});
};

PluginService.getActiveContentTemplates = function() {

    var templates = [];
    for (var uid in ACTIVE_PLUGINS) {
        var plugin = ACTIVE_PLUGINS[uid];
        if (plugin.templates) {
            var clone = pb.utils.clone(plugin.templates);
            for(var i = 0; i &lt; clone.length; i++) {
                clone[i].theme_uid = uid;
                templates.push(clone[i]);
            }
        }
    }
    return templates;
};

PluginService.prototype.getInactivePlugins = function(cb) {
	var where = {uid: {&#x27;$nin&#x27;: this.getActivePluginNames()}};
	var order = {created: pb.DAO.ASC};
	var dao   = new pb.DAO();
	dao.query(&#x27;plugin&#x27;, where, pb.DAO.SELECT_ALL, order).then(function(results) {
		if (util.isError(results)) {
			cb(results, null);
		}
		else {
			cb(null, results);
		}
	});
};

PluginService.prototype.getAvailablePlugins = function(active, inactive, cb) {
	if (util.isArray(active)) {
		active = pb.utils.arrayToHash(active, function(active, i) {
			return active[i] ? active[i].uid : &#x27;&#x27;;
		});
	}
	if (util.isArray(inactive)) {
		inactive = pb.utils.arrayToHash(inactive, function(inactive, i) {
			return inactive[i] ? inactive[i].uid : &#x27;&#x27;;
		});
	}

	pb.utils.getDirectories(PluginService.getPluginsDir(), function(err, directories) {
		if (util.isError(err)) {
			cb(err, null);
			return;
		}

		var plugins   = [];
		var tasks     = pb.utils.getTasks(directories, function(directories, i) {
			return function(callback) {

				//skip pencilblue
				var parts   = directories[i].split(path.sep);
				var dirName = parts[parts.length - 1];
				if (dirName === &#x27;pencilblue&#x27;) {
					callback(null, true);
					return;
				}

				var detailsFilePath = path.join(directories[i], DETAILS_FILE_NAME);
				PluginService.loadDetailsFile(detailsFilePath, function(err, details) {
					if (util.isError(err)) {
						plugins.push({
							uid: dirName,
							dirName: dirName,
							description: &quot;An invalid details file was provided for plugin. &quot;+err.stack
						});
						callback(null, false);
						return;
					}

					PluginService.validateDetails(details, dirName, function(err, result) {
						if (util.isError(err)) {
							plugins.push({
								uid: dirName,
								dirName: dirName,
								description: &quot;The plugin details file failed validation &quot;,
								validationErrors: err.validationErrors
							});
							callback(null, false);
							return;
						}
						else if ( (active &amp;&amp; active[details.uid]) || (inactive &amp;&amp; inactive[details.uid])) {
							callback(null, true);
							return;
						}
						details.dirName = dirName;
						plugins.push(details);
						callback(null, true);
					});
				});
			};
		});
		async.series(tasks, function(err, results) {
			cb(err, plugins);
		});
	});
};

PluginService.prototype.getPluginMap = function(cb) {
	var self  = this;
	var tasks = {

         active: function(callback) {
        	 self.getActivePlugins(callback);
         },

         inactive: function(callback) {
        	 self.getInactivePlugins(callback);
         }
	};
	async.series(tasks, function(err, results) {
		if (util.isError(err)) {
			cb(err, results);
			return;
		}

		self.getAvailablePlugins(results.active, results.inactive, function(err, available) {
			results.available = available;
			cb(err, results);
		});
	});
};

PluginService.prototype.uninstallPlugin = function(pluginUid, cb) {
	var self = this;

	//log start of operation
	if (pb.log.isDebug()) {
		pb.log.debug(&quot;PluginService:[%s] Attempting uninstall&quot;, pluginUid);
	}

	//construct sequential tasks
	var plugin = null;
	var tasks = [

         //load plugin
         function(callback) {
        	 pb.log.debug(&#x27;PluginService:[%s] Attempting to load plugin &#x27;, pluginUid);
        	 self.getPlugin(pluginUid, function(err, pluginObj) {
        		if (util.isError(err)) {
        			callback(err, false);
        			return;
        		}
        		else if (!pluginObj) {
        			callback(new Error(&quot;The [&quot;+pluginUid+&quot;] plugin is not installed&quot;), false);
        			return;
        		}
        		plugin = pluginObj;
        		callback(err, true);
        	 });
         },

         //call onUninstall
         function(callback) {
        	 if (!PluginService.isActivePlugin(pluginUid)) {
        		 pb.log.warn(&quot;PluginService:[%s] Skipping call to plugin&#x27;s onUninstall function.  Main module was not active.&quot;, pluginUid);
        		 callback(null, true);
        		 return;
        	 }

        	 var mm = ACTIVE_PLUGINS[pluginUid].main_module;
        	 if (typeof mm.onUninstall === &#x27;function&#x27;) {
        		 pb.log.debug(&#x27;PluginService:[%s] Calling plugin onUnstall&#x27;, pluginUid);

        		 mm.onUninstall(callback);
        	 }
        	 else {
        		 pb.log.debug(&#x27;PluginService:[%s] Plugin onUninstall function does not exist.  Skipping.&#x27;, pluginUid);
        		 callback(null, true);
        	 }
         },

         //unregister routes
         function(callback) {
        	 var routesRemoved = pb.RequestHandler.unregisterThemeRoutes(plugin.uid);
        	 pb.log.debug(&#x27;PluginService:[%s] Unregistered %d routes&#x27;, pluginUid, routesRemoved);
        	 process.nextTick(function(){callback(null, true);});
         },

         //remove localization
         function(callback) {
        	 //TODO refactor localization to figure out how to remove only those
        	 //that were overriden. For now any overriden localizations will be
        	 //left until the server cycles.  This is not ideal but will suffice
        	 //for most use cases.  The only affected use case is if a default
        	 //label is overriden.
        	 process.nextTick(function(){callback(null, false);});
         },

         //remove settings
         function(callback) {
     		self.pluginSettingsService.purge(pluginUid, function (err, result) {
     			callback(err, !util.isError(err) &amp;&amp; result);
     		});
         },

         //remove theme settings
         function(callback) {
     		self.themeSettingsService.purge(pluginUid, function (err, result) {
     			callback(err, !util.isError(err) &amp;&amp; result);
     		});
         },

         //remove plugin record from &quot;plugin&quot; collection
         function(callback) {
        	 var dao = new pb.DAO();
        	 dao.deleteById(plugin._id, &#x27;plugin&#x27;).then(function(result) {
        		var error = util.isError(result) ? result : null;
        		callback(error, error == null);
        	 });
         },

         //roll over to default theme
         function(callback) {
        	pb.settings.set(&#x27;active_theme&#x27;, &#x27;pencilblue&#x27;, function(err, result) {
        		callback(err, result ? true : false);
        	});
         },

         //remove from ACTIVE_PLUGINS//unregister services
         function(callback) {
        	 delete ACTIVE_PLUGINS[pluginUid];
        	 process.nextTick(function(){callback(null, false);});
         }
    ];
	async.series(tasks, function(err, results) {
		cb(err, !util.isError(err));
	});
};

/**
 * Installs a plugin by stepping through a series of steps that must be
 * completed in order.  There is currently no fallback plan for a failed install.
 * In order for a plugin to be fully installed it must perform the following
 * actions without error:
 * &lt;ol&gt;
 * &lt;li&gt;Load and parse the plugin&#x27;s details.json file&lt;/li&gt;
 * &lt;li&gt;Pass validation&lt;/li&gt;
 * &lt;li&gt;Must not already be installed&lt;/li&gt;
 * &lt;li&gt;Successfully register itself with the system&lt;/li&gt;
 * &lt;li&gt;Successfully load any plugin settings&lt;/li&gt;
 * &lt;li&gt;Successfully load any theme settings&lt;/li&gt;
 * &lt;li&gt;Successfully execute the plugin&#x27;s onInstall function&lt;/li&gt;
 * &lt;li&gt;Successfully initialize the plugin for runtime&lt;/li&gt;
 * &lt;/ol&gt;
 * @method installPlugin
 * @param {string} pluginDirName The name of the directory that contains the
 * plugin and its details.json file.
 * @param {function} cb A callback that provides two parameters: cb(err, TRUE/FALSE)
 */
PluginService.prototype.installPlugin = function(pluginDirName, cb) {
	var self            = this;
	var detailsFilePath = PluginService.getDetailsPath(pluginDirName);
	var details         = null;
	var plugin          = null;

	pb.log.info(&quot;PluginService: Beginning install of %s&quot;, pluginDirName);
	var tasks = [

         //load the details file
         function(callback) {
        	 pb.log.info(&quot;PluginService: Attempting to load details.json file for %s&quot;, pluginDirName);

			PluginService.loadDetailsFile(detailsFilePath, function(err, loadedDetails) {
				details = loadedDetails;
				callback(err, null);
			});
         },

         //validate the details
         function(callback) {
        	 pb.log.info(&quot;PluginService: Validating details of %s&quot;, pluginDirName);

        	 PluginService.validateDetails(details, pluginDirName, callback);
         },

         //verify that the plugin is not installed
         function(callback) {
        	 pb.log.info(&quot;PluginService: Verifying that plugin %s is not already installed&quot;, details.uid);

        	 self.isInstalled(details.uid, function(err, isInstalled){
        		if (util.isError(err)) {
        			callback(err, isInstalled);
        		}
        		else {
        			err = isInstalled ? (new Error(&#x27;PluginService: The &#x27;+details.uid+&#x27; plugin is already installed&#x27;)) : null;
        			callback(err, isInstalled);
                }
             });
         },

        //create plugin entry
        function(callback) {
        	 pb.log.info(&quot;PluginService: Setting system install flags for %s&quot;, details.uid);

        	 var clone     = pb.utils.clone(details);
        	 clone.dirName = pluginDirName;

        	 var pluginDescriptor = pb.DocumentCreator.create(&#x27;plugin&#x27;, clone);
        	 var dao              = new pb.DAO();
        	 dao.update(pluginDescriptor).then(function(result) {
        		 plugin = pluginDescriptor;
        		 callback(util.isError(result) ? result : null, result);
        	 });
         },

         //load plugin settings
         function(callback) {
        	 pb.log.info(&quot;PluginService: Adding settings for %s&quot;, details.uid);
        	 self.resetSettings(details, callback);
         },

         //load theme settings
         function(callback) {
        	 if (details.theme &amp;&amp; details.theme.settings) {
        		 pb.log.info(&quot;PluginService: Adding theme settings for %s&quot;, details.uid);

        		 self.resetThemeSettings(details, callback);
        	 }
        	 else {
        		 callback(null, null);
        	 }
         },

        //call plugin&#x27;s onInstall function
        function(callback) {

            var mainModule = PluginService.loadMainModule(pluginDirName, details.main_module.path);
    		if (mainModule !== null &amp;&amp; typeof mainModule.onInstall === &#x27;function&#x27;) {
    			pb.log.info(&quot;PluginService: Executing %s &#x27;onInstall&#x27; function&quot;, details.uid);
    			mainModule.onInstall(callback);
    		}
    		else {
    			pb.log.warn(&quot;PluginService: Plugin %s did not provide an &#x27;onInstall&#x27; function.&quot;, details.uid);
    			callback(null, false);
    		}
        },

         //do plugin initialization
         function(callback) {
        	pb.log.info(&quot;PluginService: Initializing %s&quot;, details.uid);
        	self.initPlugin(plugin, callback);
         },

         //notify cluster of plugin install
         function(callback) {
        	 pb.log.warn(&quot;PluginService: Cluster Notification for install of %s is not yet supported&quot;, pluginDirName);
        	 //TODO PluginInstall Notifications across cluster
        	callback(null, null);
         }
	];
	async.series(tasks, function(err, results) {
		cb(err, !util.isError(err));
	});
};

PluginService.prototype.initPlugins = function(cb) {
	pb.log.debug(&#x27;PluginService: Beginning plugin initilization...&#x27;);

	var self = this;
	var dao  = new pb.DAO();
	dao.query(&#x27;plugin&#x27;).then(function(plugins) {
		if (util.isError(plugins)) {
			cb(plugins, null);
			return;
		}
		else if (!util.isArray(plugins)) {
			var err = new Error(&#x27;An array of plugins was expected but found [&#x27;+(typeof plugins)+&#x27;][&#x27;+util.inspect(plugins)+&#x27;] instead.&#x27;);
			pb.log.error(&#x27;PluginService %s&#x27;, err.stack);
			cb(err, plugins);
			return;
		}

		//make sure there are plugins to initialize
		if (plugins.length === 0) {
			pb.log.debug(&#x27;PluginService: No plugins are installed&#x27;);
			cb(null, true);
			return;
		}
		var tasks  = pb.utils.getTasks(plugins, function(plugins, i) {
			return function(callback) {

				try {
					self.initPlugin(plugins[i], function(err, didInitialize) {
						process.nextTick(function() {
							callback(null, {plugin: plugins[i], error: err, initialized: didInitialize});
						});
					});
				}
				catch(err) {
					callback(null, {plugin: plugins[i], error: err, initialized: false});
				}
			};
		});
		async.series(tasks, function(err, results) {

			for (var i = 0; i &lt; results.length; i++) {

				var result = results[i];
				if (result.initialized === true) {
					pb.log.debug(&#x27;PluginService: Plugin [%s] was successfully initialized&#x27;, result.plugin.name);
				}
				else {
					pb.log.warn(&#x27;PluginService: Plugin [%s] failed to initialize.&#x27;+result.initialized, result.plugin.name);
				}
				if (result.error) {
					pb.log.error(&#x27;PluginService: The following error was produced while initializing the %s plugin: %s&#x27;, result.plugin.name, result.error.stack);
				}
			}

			cb(err, true);
		});
	});
};

/**
 * Initializes a plugin during startup or just after a plugin has been installed.
 * @param {plugin} pluginName
 * @param {function} cb
 */
PluginService.prototype.initPlugin = function(plugin, cb) {
	var self = this;

	if (typeof plugin !== &#x27;object&#x27;) {
		cb(new Error(&#x27;PluginService:[INIT] The plugin object must be passed in order to initilize the plugin&#x27;), null);
		return;
	}

	pb.log.info(&quot;PluginService:[INIT] Beginning initialization of %s (%s)&quot;, plugin.name, plugin.uid);

	var details = null;
	var tasks   = [

         //load the details file
         function(callback) {
        	 pb.log.debug(&quot;PluginService:[INIT] Attempting to load details.json file for %s&quot;, plugin.name);

			PluginService.loadDetailsFile(PluginService.getDetailsPath(plugin.dirName), function(err, loadedDetails) {
				details = loadedDetails;
				callback(err, null);
			});
         },

         //validate the details
         function(callback) {
        	 pb.log.debug(&quot;PluginService:[INIT] Validating details of %s&quot;, plugin.name);

        	 PluginService.validateDetails(details, plugin.dirName, callback);
         },

         //check for discrepencies
         function(callback) {
        	 if (plugin.uid != details.uid) {
        		 pb.log.warn(&#x27;PluginService:[INIT] The UID [%s] for plugin %s does not match what was found in the details.json file [%s].  The details file takes precendence.&#x27;, plugin.uid, plugin.name, details.uid);
        	 }
        	 process.nextTick(function() {callback(null, true);});
         },

         //register plugin &amp; load main module
         function(callback) {

        	 //convert perm array to hash
        	 var map = {};
        	 if (plugin.permissions) {
                 pb.log.debug(&#x27;PluginService:[INIT] Loading permission sets for plugin [%s]&#x27;, details.uid);

        		 for (var role in plugin.permissions) {
        			 map[role] = pb.utils.arrayToHash(plugin.permissions[role]);
        		 }
        	 }
             else {
                 pb.log.debug(&#x27;PluginService:[INIT] Skipping permission set load for plugin [%s]. None were found.&#x27;, details.uid);
             }

        	 //create cached active plugin structure
             var templates  = null;
             if (details.theme &amp;&amp; details.theme.content_templates) {
                 templates = details.theme.content_templates;
                 for (var i = 0; i &lt; templates.length; i++) {
                    templates[i].theme_name = details.name;
                 }
             }
        	 var mainModule = PluginService.loadMainModule(plugin.dirName, details.main_module.path);
        	 ACTIVE_PLUGINS[details.uid] = {
    			 main_module: mainModule,
    			 public_dir: PluginService.getPublicPath(plugin.dirName),
    			 permissions: map,
                 templates: templates
        	 };

        	 //set icon url (if exists)
        	 if (details.icon) {
        		 ACTIVE_PLUGINS[details.uid].icon = PluginService.genPublicPath(details.uid, details.icon);
        	 }
        	 process.nextTick(function() {callback(null, true);});
         },

         //call plugin&#x27;s onStartup function
         function(callback) {
        	var mainModule = ACTIVE_PLUGINS[details.uid].main_module;
        	if (typeof mainModule.onStartup === &#x27;function&#x27;) {

                var timeoutProtect = setTimeout(function() {

                    // Clear the local timer variable, indicating the timeout has been triggered.
                    timeoutProtect = null;
                    callback(new Error(&quot;PluginService: Startup function for plugin &quot;+details.uid+&quot; never called back!&quot;), false);

                }, 2000);

                //attempt to make connection
                var d = domain.create();
                d.on(&#x27;error&#x27;, function(err) {
                    if (timeoutProtect) {
                        clearTimeout(timeoutProtect);
                        callback(err, false);
                    }
                    else {
                        pb.log.error(&#x27;PluginService:[INIT] Plugin %s failed to start. %s&#x27;, details.uid, err.stack);
                    }
                });
                d.run(function() {
                    mainModule.onStartup(function(err, didStart) {
                        if (util.isError(err)) {
                            throw err;
                        }

                        if (timeoutProtect) {
                            clearTimeout(timeoutProtect);
                            callback(err, didStart);
                        }
                    });
                });
        	}
        	else {
        		pb.log.warn(&quot;PluginService: Plugin %s did not provide an &#x27;onStartup&#x27; function.&quot;, details.uid);
        		callback(null, false);
        	}
         },

         //load services
         function(callback) {
        	 PluginService.getServices(path.join(PLUGINS_DIR, plugin.dirName), function(err, services) {
        		 if (util.isError(err)) {
        			 pb.log.debug(&quot;PluginService[INIT]: No services directory was found for %s&quot;, details.uid);
        		 }
        		 if (!services) {
        			 pb.log.debug(&quot;PluginService[INIT]: No services were found for %s&quot;, details.uid);
        			 services = {};
        		 }
        		 ACTIVE_PLUGINS[details.uid].services = services;
        		 callback(null, !util.isError(err));
        	 });
         },

         //process routes
         function(callback) {
        	 PluginService.loadControllers(path.join(PLUGINS_DIR, plugin.dirName), details.uid, callback);
         },

         //process localization
         function(callback) {

        	 self.getLocalizations(plugin.dirName, function(err, localizations) {
        		 for (var locale in localizations) {
        			 if (pb.log.isDebug()) {
        				 pb.log.debug(&#x27;PluginService:[%s] Registering localizations for locale [%s]&#x27;, details.uid, locale);
        			 }

        			 var result = pb.Localization.registerLocalizations(locale, localizations[locale]);
        			 if (!result &amp;&amp; pb.log.isDebug()) {
        				 pb.log.debug(&#x27;PluginService:[%s] Failed to register localizations for locale [%s].  Is the locale supported in your configuration?&#x27;, details.uid, locale);
        			 }
        		 }
        		 callback(null, !util.isError(err));
        	 });
         }
    ];
	async.series(tasks, function(err, results) {
		//cleanup on error
		if (util.isError(err) &amp;&amp; details &amp;&amp; details.uid) {
			delete ACTIVE_PLUGINS[details.uid];
		}

		//callback with final result
		cb(err, !util.isError(err));
	});
};

PluginService.prototype.getLocalizations = function(pluginDirName, cb) {
	var localizationDir = path.join(PluginService.getPublicPath(pluginDirName), &#x27;localization&#x27;);

	fs.readdir(localizationDir, function(err, files) {
		if (util.isError(err)) {
			cb(err, null);
			return;
		}

		var localizations = {};
		var tasks = pb.utils.getTasks(files, function(files, index) {
			return function(callback) {

				var pathToLocalization = path.join(localizationDir, files[index]);
				fs.readFile(pathToLocalization, function(err, json) {
					if (!util.isError(err)) {

						//attempt to parse JSON and set service
						try {
							var localization    = JSON.parse(json);
							var name            = PluginService.getServiceName(pathToLocalization);
							localizations[name] = localization;
						}
						catch(e) {
							pb.log.warn(&#x27;PluginService:[%s] Failed to parse localization JSON file at [%s]. %s&#x27;, pluginDirName, pathToLocalization, e.stack);
						}
					}
					else {
						pb.log.warn(&#x27;PluginService:[%s] Failed to load localization JSON file at [%s]&#x27;, pluginDirName, pathToLocalization);
					}
					callback(null, true);
				});
			};
		});
		async.parallel(tasks, function(err, results) {
			cb(err, localizations);
		});
	});
};

PluginService.prototype.getService = function(serviceName, pluginUid) {
	if (ACTIVE_PLUGINS[pluginUid]) {
		if (ACTIVE_PLUGINS[pluginUid].services &amp;&amp; ACTIVE_PLUGINS[pluginUid].services[serviceName]) {
			return ACTIVE_PLUGINS[pluginUid].services[serviceName];
		}
	}
	return null;
};

PluginService.loadMainModule = function(pluginDirName, pathToModule) {
	var pluginMM = path.join(PLUGINS_DIR, pluginDirName, pathToModule);
	var paths    = [pluginMM, pathToModule];

	var mainModule = null;
	for (var i = 0; i &lt; paths.length; i++) {
		try {
			mainModule = require(paths[i]);
			break;
		}
		catch(e) {}
	}
	return mainModule;
};

/**
 * Retrieves the absolute file path to a plugin&#x27;s public directory
 *
 * @static
 * @method getPublicPath
 * @param pluginDirName The name of the directory that contains the intended
 * plugin
 * @return {string} the absolute file path to a plugin&#x27;s public directory
 */
PluginService.getPublicPath = function(pluginDirName) {
	return path.join(PLUGINS_DIR, pluginDirName, PUBLIC_DIR_NAME);
};

/**
 * @return {string} The absolute file path to the plugins directory
 */
PluginService.getPluginsDir = function() {
	return PLUGINS_DIR;
};

/**
 * Constructs the path to a specific plugin&#x27;s details.json file
 * @return {string} The absolute file path to the details.json file for a plugin
 */
PluginService.getDetailsPath = function(pluginDirName) {
	return path.join(PLUGINS_DIR, pluginDirName, DETAILS_FILE_NAME);
};

/**
 * Attempts to load and parse the details.json file for a plugin.
 * @param filePath The absolute path to the details.json file
 * @param cb A callback that provides two parameters: cb(error, detailsObject)
 */
PluginService.loadDetailsFile = function(filePath, cb) {
	fs.readFile(filePath, function(err, data){
		if (util.isError(err)) {
			cb(err, null);
			return;
		}

		//atempt to parse the json
		try {
			cb(null, JSON.parse(data));
		}
		catch(e) {
			e.message = &quot;Failed to parse json file [&quot;+filePath+&#x27;]. &#x27;+e.message;
			e.code    = 500;
			e.source  = e;
			cb(e, null);
		}
	});
};

/**
 * Validates a plugin&#x27;s details.json file.
 *
 * @param details The details object to validate
 * @param pluginDirName The name of the directory containing the original
 * details.json file that the details object was derived from.
 * @param cb A callback that provides two parameters: cb(error, TRUE/FALSE).
 * TRUE if the details object passes validation, FALSE if not.
 */
PluginService.validateDetails = function(details, pluginDirName, cb) {
	if (!details) {
		cb(new Error(&quot;Details cannot be null&quot;), false);
		return;
	}

	//setup
	var errors = [];
	var v      = pb.validation;

	//validate uid
	if (!v.validateSafeFileName(details.uid, true)) {
		errors.push(&quot;The uid field must be provided and can only contain alphanumerics, underscores, and dashes&quot;);
	}

	//validate display name
	if (!v.validateNonEmptyStr(details.name, true)) {
		errors.push(&quot;An invalid name [&quot;+details.name+&quot;] was provided&quot;);
	}

	//validate description
	if (!v.validateNonEmptyStr(details.description, true)) {
		errors.push(&quot;A valid description must be provided&quot;);
	}

	//validate version
	if (!v.validateVersionNum(details.version, true)) {
		errors.push(&quot;An invalid version number [&quot;+details.version+&quot;] was provided.  Must match the form: xx.xx.xx&quot;);
	}

	//validate icon
	if (details.icon) {
		if (!pb.utils.isString(details.icon) || !PluginService.validateIconPath(details.icon, pluginDirName)) {
			errors.push(&quot;The optional plugin icon must be a valid path to an image&quot;);
		}
	}

	//validate author block
	if (details.author) {
		var author = details.author;

		//validate name
		if (!v.validateNonEmptyStr(author.name, true)) {
			errors.push(&quot;A valid author name must be provided&quot;);
		}

		//validate email
		if (!v.validateEmail(author.email, true)) {
			errors.push(&quot;A valid author email must be provided&quot;);
		}

		//validate website
		if (!v.validateUrl(author.website, false)) {
			errors.push(&quot;The website address is not a valid URL&quot;);
		}

		//validate contributors
		if (author.contributors) {
			if (v.validateArray(author.contributors, true)) {

				for (var i = 0; i &lt; author.contributors.length; i++) {

					var cont = author.contributors[i];
					if (v.validateObject(cont, true)) {

						//validate contributor name
						if (!v.validateNonEmptyStr(cont.name, true)) {
							errors.push(&quot;The contributor name at position &quot;+i+&quot; must be provided&quot;);
						}

						//validate contributor email
						if (!v.validateEmail(cont.email, false)) {
							errors.push(&quot;The contributor email at position &quot;+i+&quot; is invalid&quot;);
						}
					}
					else {
						errors.push(&quot;The contributor at position &quot;+i+&quot; must be an object&quot;);
					}
				}
			}
			else {
				errors.push(&quot;The author contributors block must be an array&quot;);
			}
		}
	}
	else {
		errors.push(&quot;The author block is required&quot;);
	}

	//validate plugin settings
	if (details.settings) {

		if (v.validateArray(details.settings, true)) {

			//validate each setting
			for (var i = 0; i &lt; details.settings.length; i++) {

				//set any errors derived
				var settingErrs = PluginService.validateSetting(details.settings[i], i);
				for (var j = 0; j &lt; settingErrs.length; j++) {
					errors.push(settingErrs[j]);
				}
			}
		}
		else {
			errors.push(&quot;The settings block must be an array&quot;);
		}
	}

	//validate permissions
	if (v.validateObject(details.permissions, true)) {

		var validKeys = {&quot;ACCESS_USER&quot;: 1, &quot;ACCESS_WRITER&quot;: 1, &quot;ACCESS_EDITOR&quot;: 1, &quot;ACCESS_MANAGING_EDITOR&quot;: 1};
		for (var key in details.permissions) {

			//validate permission key
			if (validKeys[key] === undefined) {
				errors.push(new Error(&quot;An invalid permissions map key [&quot;+key+&quot;] was provided&quot;));
			}
			else {
				var val = details.permissions[key];
				if (v.validateArray(val, true)) {

					for (var i = 0; i &lt; details.permissions[key].length; i++) {
						if (!v.validateNonEmptyStr(details.permissions[key][i], true)) {
							errors.push(&quot;The value at position &quot;+i+&quot; for permissions map key [&quot;+key+&quot;] is invalid&quot;);
						}
					}
				}
				else {
					errors.push(&quot;Permissions map key [&quot;+key+&quot;] was provided must provide an array of permissions&quot;);
				}
			}
		}
	}
	else {
		errors.push(&quot;The permissions block is required and must be an object&quot;);
	}

	//validate main module
	if (v.validateObject(details.main_module, true)) {

		if (!PluginService.validateMainModulePath(details.main_module.path, pluginDirName)) {
			errors.push(&quot;An invalid main module path and/or file was provided&quot;);
		}
	}
	else {
		errors.push(&quot;The main module block is required and must be an object&quot;);
	}

	//validate theme
	if (details.theme) {

		if (v.validateObject(details.theme, true)) {

			//validate settings block
			if (details.theme.settings) {

				if (v.validateArray(details.theme.settings, true)) {

					//validate each setting
					for (var i = 0; i &lt; details.theme.settings.length; i++) {

						//set any errors derived
						var settingErrs = PluginService.validateSetting(details.theme.settings[i], i);
						for (var j = 0; j &lt; settingErrs.length; j++) {
							errors.push(settingErrs[j]);
						}
					}
				}
				else {
					errors.push(&quot;The theme settings block must be an array&quot;);
				}
			}

			//validate theme content templates
			if (details.theme.content_templates) {

				if (v.validateArray(details.theme.content_templates, true)) {

					//validate each content template
					for (var i = 0; i &lt; details.theme.content_templates.length; i++) {

						var template = details.theme.content_templates[i];
						if (v.validateObject(template, true)) {

							//validate content template name
							if (!v.validateNonEmptyStr(template.name, true)) {
								errors.push(&quot;The content template name at position &quot;+i+&quot; is invalid&quot;);
							}

							//validate content template file
							if (!v.validateSafeFileName(template.file, true)) {
								errors.push(&quot;The content template file at position &quot;+i+&quot; is invalid&quot;);
							}
						}
						else {
							errors.push(&quot;The content template at position &quot;+i+&quot; is invalid&quot;);
						}
					}
				}
				else {
					errors.push(&quot;The content templates property must be an array&quot;);
				}
			}
		}
		else {
			errors.push(&quot;The theme block must be an object&quot;);
		}
	}

	//prepare validation response
	var error   = null;
	var isError = errors.length &gt; 0;
	if (isError) {
		error = new Error(&quot;Faled to validate plugin details&quot;);
		error.validationErrors = errors;
	}
	cb(error, !isError);
};

/**
 * Validates the path to the plugin&#x27;s icon file.  The path is considered valid
 * if the path to a valid file.  The path may be absolute or relative to the
 * plugin&#x27;s public directory.
 *
 * @param iconPath The path to the icon (image) file
 * @param pluginDirName The name of the directory housing the plugin
 * @return {Boolean} TRUE if the path is valid, FALSE if not
 */
PluginService.validateIconPath = function(iconPath, pluginDirName) {
	var pluginPublicIcon = path.join(PluginService.getPublicPath(pluginDirName), iconPath);
	var paths            = [pluginPublicIcon, iconPath];

	for (var i = 0; i &lt; paths.length; i++) {
		if (fs.existsSync(paths[i])) {
			return true;
		}
	}
	return false;
};

/**
 * Validates the path of a main module file.  The path is considered valid if
 * the path points to JS file.  The path may be absolute or relative to the
 * specific plugin directory.
 *
 * @param mmPath The relative or absolute path to the main module file
 * @param pluginDirName The name of the directory housing the plugin
 * @return {Boolean} TRUE if the path is valid, FALSE if not
 */
PluginService.validateMainModulePath = function(mmPath, pluginDirName) {
	return PluginService.loadMainModule(pluginDirName, mmPath) !== null;
};

/**
 * Validates a setting from a details.json file.
 *
 * @param setting The setting to validate
 * @param position The position in the settings array where the setting resides
 * as a 0 based index.
 * @return {Array} The array of errors that were generated.  If no errors were
 * produced an empty array is returned.
 */
PluginService.validateSetting = function(setting, position) {

	//setup
	var errors = [];
	var v      = pb.validation;

	//validate object
	if (pb.utils.isObject(setting)) {

		//validate name
		if (!v.validateNonEmptyStr(setting.name, true)) {
			errors.push(new Error(&quot;The setting name at position &quot;+position+&quot; must be provided&quot;));
		}

		//validate value
		if (!PluginService.validateSettingValue(setting.value)) {
			errors.push(new Error(&quot;The setting value at position &quot;+position+&quot; must be provided&quot;));
		}
	}
	else {
		errors.push(new Error(&quot;The setting value at position &quot;+position+&quot; must be an object&quot;));
	}

	return errors;
};

/**
 * Validates a details.json file&#x27;s setting value.  The value is required to be a
 * string or a number.  Null, undefined, Arrays, Objects, and prototypes are NOT
 * allowed.
 *
 * @param value The value to validate
 * @return {Boolean} TRUE if the value is valid, FALSE if not
 */
PluginService.validateSettingValue = function(value) {
	return pb.utils.isString(value) || !isNaN(value) || value === true || value === false;
};

/**
 * Retrieves all services (initialized).  The services are provided in the
 * callback.
 *
 * @param pathToPlugin The absolute file path to the specific plugin directory.
 * @param cb A callback that provides two parameters: cb(error, servicesHash);
 */
PluginService.getServices = function(pathToPlugin, cb) {
	var servicesDir = path.join(pathToPlugin, &#x27;services&#x27;);

	fs.readdir(servicesDir, function(err, files) {
		if (util.isError(err)) {
			cb(err, null);
			return;
		}

		var services = {};
		var tasks = pb.utils.getTasks(files, function(files, index) {
			return function(callback) {

				var pathToService = path.join(servicesDir, files[index]);
				PluginService.loadService(pathToService, function(err, service) {
					if (!util.isError(err)) {

						var name = PluginService.getServiceName(pathToService, service);
						services[name] = service;
					}
					else {
						pb.log.warn(&#x27;PluginService: Failed to load service at [%s]&#x27;, pathToService);
					}
					callback(null, true);
				});
			};
		});
		async.parallel(tasks, function(err, results) {
			cb(err, services);
		});
	});
};

/**
 * Loads a plugin service and initializes it.  The service is required to
 * implement an &quot;init&quot; function. The service is then provided as a parameter in
 * the callback.
 *
 * @param pathToService The absolute file path to the service javascript file.
 * @param cb A callback that provides two parameters: cb(error, initializedService)
 */
PluginService.loadService = function(pathToService, cb) {
	try {
		pb.log.debug(&quot;PluginService: Attempting to load service [&quot;+pathToService+&quot;]&quot;);
		var service = require(pathToService);

		pb.log.debug(&quot;PluginService: Initializing service [&quot;+pathToService+&quot;]&quot;);
		service.init(function(err, result) {
			cb(err, service);
		});
	}
	catch(e){
		pb.log.error(&quot;PluginService: Failed to load service: [&quot;+pathToService+&quot;]: &quot;+e.stack);
		cb(e, null);
	}
};

PluginService.loadControllers = function(pathToPlugin, pluginUid, cb) {
	var controllersDir = path.join(pathToPlugin, &#x27;controllers&#x27;);

	fs.readdir(controllersDir, function(err, files) {
		if (util.isError(err)) {
            pb.log.debug(&#x27;PluginService[INIT]: The controllers directory [%s] does not exist or could not be read.&#x27;, controllersDir);
            pb.log.silly(&#x27;PluginService[INIT]: %s&#x27;, err.stack);
			cb(null, []);
            return;
		}

		var tasks = pb.utils.getTasks(files, function(files, index) {
			return function(callback) {

				var pathToController = path.join(controllersDir, files[index]);
				PluginService.loadController(pathToController, pluginUid, function(err, service) {
					if (util.isError(err)) {
						pb.log.warn(&#x27;PluginService: Failed to load controller at [%s]: %s&#x27;, pathToController, err.stack);
					}
					callback(null, util.isError(err));
				});
			};
		});
		async.parallel(tasks, function(err, results) {
			cb(err, results);
		});
	});
};

PluginService.loadController = function(pathToController, pluginUid, cb) {
	try {

		//load the controller type
		var ControllerPrototype = require(pathToController);

		//ensure we can get the routes
		if (typeof ControllerPrototype.getRoutes !== &#x27;function&#x27;){
			throw new Error(&#x27;Controller at [&#x27;+pathToController+&#x27;] does not implement function &quot;getRoutes&quot;&#x27;);
		}

		//get the routes
		ControllerPrototype.getRoutes(function(err, routes) {
			if (util.isError(err)) {
				cb(err, null);
				return;
			}
			else if (!util.isArray(routes)) {
				cb(new Error(&#x27;Controller at [&#x27;+pathToController+&#x27;] did not return an array of routes&#x27;), null);
				return;
			}

			//attempt to register route
			for(var i = 0; i &lt; routes.length; i++) {
				var route        = routes[i];
				route.controller = pathToController;
				var result       = pb.RequestHandler.registerRoute(route, pluginUid);

				//verify registration
				if (!result) {
					pb.log.warn(&#x27;PluginService: Failed to register route [%s] for controller at [%s]&#x27;, util.inspect(route), pathToController);
				}
			}

			//do callback
			cb(null, true);
		});
	}
	catch(err) {
		cb(err, null);
	}
};

/**
 * Derives the name of a plugin service instance.  The function attempts to get
 * the name of the service by looking to see if the service has implemented the
 * getName function.  If it has not then the service name is set to be the file
 * name minus any extension.
 *
 * @param pathToService The file path to the service
 * @param service The service prototype
 * @return {String} The derived service name
 */
PluginService.getServiceName = function(pathToService, service) {
	var name = &#x27;UNKNOWN&#x27;;
	if (service &amp;&amp; typeof service.getName === &#x27;function&#x27;) {
		name = service.getName();
	}
	else {
		var pieces = pathToService.split(path.sep);
		name       = pieces[pieces.length - 1];
		var index  = name.lastIndexOf(&#x27;.&#x27;);
		if (index &gt; 0) {
			name = name.substring(0, index);
		}
	}
	return name;
};

//exports
module.exports = PluginService;

    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
