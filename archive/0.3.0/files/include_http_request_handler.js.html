<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>include\http\request_handler.js - PencilBlue</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="http://pencilblue.org/img/pb_logo.png" title="PencilBlue"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.3.0</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="../classes/AdminChangePasswordController.html">AdminChangePasswordController</a></li>
            
                <li><a href="../classes/AdminIndexController.html">AdminIndexController</a></li>
            
                <li><a href="../classes/AdminNavigation.html">AdminNavigation</a></li>
            
                <li><a href="../classes/AdminSubnavService.html">AdminSubnavService</a></li>
            
                <li><a href="../classes/ApiActionController.html">ApiActionController</a></li>
            
                <li><a href="../classes/ArticleService.html">ArticleService</a></li>
            
                <li><a href="../classes/AsyncJobRunner.html">AsyncJobRunner</a></li>
            
                <li><a href="../classes/BaseController.html">BaseController</a></li>
            
                <li><a href="../classes/CacheEntityService.html">CacheEntityService</a></li>
            
                <li><a href="../classes/CacheFactory.html">CacheFactory</a></li>
            
                <li><a href="../classes/ChangePasswordFormController.html">ChangePasswordFormController</a></li>
            
                <li><a href="../classes/ClientJS.html">ClientJS</a></li>
            
                <li><a href="../classes/ClusterApiController.html">ClusterApiController</a></li>
            
                <li><a href="../classes/ClusterJobRunner.html">ClusterJobRunner</a></li>
            
                <li><a href="../classes/CommandService.html">CommandService</a></li>
            
                <li><a href="../classes/CommentService.html">CommentService</a></li>
            
                <li><a href="../classes/ContentService.html">ContentService</a></li>
            
                <li><a href="../classes/CustomObjectService.html">CustomObjectService</a></li>
            
                <li><a href="../classes/DAO.html">DAO</a></li>
            
                <li><a href="../classes/DBEntityService.html">DBEntityService</a></li>
            
                <li><a href="../classes/DBManager.html">DBManager</a></li>
            
                <li><a href="../classes/DeleteArticleActionController.html">DeleteArticleActionController</a></li>
            
                <li><a href="../classes/DeleteMediaController.html">DeleteMediaController</a></li>
            
                <li><a href="../classes/DocumentCreator.html">DocumentCreator</a></li>
            
                <li><a href="../classes/EditMediaActionController.html">EditMediaActionController</a></li>
            
                <li><a href="../classes/EditObject.html">EditObject</a></li>
            
                <li><a href="../classes/EditObjectType.html">EditObjectType</a></li>
            
                <li><a href="../classes/EmailService.html">EmailService</a></li>
            
                <li><a href="../classes/ErrorsOverTime.html">ErrorsOverTime</a></li>
            
                <li><a href="../classes/ForgotPasswordController.html">ForgotPasswordController</a></li>
            
                <li><a href="../classes/FormBodyParser.html">FormBodyParser</a></li>
            
                <li><a href="../classes/FormController.html">FormController</a></li>
            
                <li><a href="../classes/FSEntityService.html">FSEntityService</a></li>
            
                <li><a href="../classes/FsMediaProvider.html">FsMediaProvider</a></li>
            
                <li><a href="../classes/ImportWP.html">ImportWP</a></li>
            
                <li><a href="../classes/JobApiController.html">JobApiController</a></li>
            
                <li><a href="../classes/JobRunner.html">JobRunner</a></li>
            
                <li><a href="../classes/JobService.html">JobService</a></li>
            
                <li><a href="../classes/JsonBodyParser.html">JsonBodyParser</a></li>
            
                <li><a href="../classes/JSONFSEntityService.html">JSONFSEntityService</a></li>
            
                <li><a href="../classes/LibrariesService.html">LibrariesService</a></li>
            
                <li><a href="../classes/Localization.html">Localization</a></li>
            
                <li><a href="../classes/ManageComments.html">ManageComments</a></li>
            
                <li><a href="../classes/ManageObjects.html">ManageObjects</a></li>
            
                <li><a href="../classes/ManageObjectTypes.html">ManageObjectTypes</a></li>
            
                <li><a href="../classes/MediaContentController.html">MediaContentController</a></li>
            
                <li><a href="../classes/MediaForm.html">MediaForm</a></li>
            
                <li><a href="../classes/MediaLoader.html">MediaLoader</a></li>
            
                <li><a href="../classes/MediaService.html">MediaService</a></li>
            
                <li><a href="../classes/MemoryEntityService.html">MemoryEntityService</a></li>
            
                <li><a href="../classes/MongoCommandBroker.html">MongoCommandBroker</a></li>
            
                <li><a href="../classes/MongoMediaProvider.html">MongoMediaProvider</a></li>
            
                <li><a href="../classes/MongoRegistrationProvider.html">MongoRegistrationProvider</a></li>
            
                <li><a href="../classes/MongoSessionStore.html">MongoSessionStore</a></li>
            
                <li><a href="../classes/NavItemFormController.html">NavItemFormController</a></li>
            
                <li><a href="../classes/NewObjectActionController.html">NewObjectActionController</a></li>
            
                <li><a href="../classes/NewObjectTypeActionController.html">NewObjectTypeActionController</a></li>
            
                <li><a href="../classes/NewPagePostController.html">NewPagePostController</a></li>
            
                <li><a href="../classes/NotFoundController.html">NotFoundController</a></li>
            
                <li><a href="../classes/ObjectFormController.html">ObjectFormController</a></li>
            
                <li><a href="../classes/PageController.html">PageController</a></li>
            
                <li><a href="../classes/PBError.html">PBError</a></li>
            
                <li><a href="../classes/PencilBlue.html">PencilBlue</a></li>
            
                <li><a href="../classes/PluginApi.html">PluginApi</a></li>
            
                <li><a href="../classes/PluginAvailableJob.html">PluginAvailableJob</a></li>
            
                <li><a href="../classes/PluginDependenciesJob.html">PluginDependenciesJob</a></li>
            
                <li><a href="../classes/PluginDetailsViewController.html">PluginDetailsViewController</a></li>
            
                <li><a href="../classes/PluginInitializeJob.html">PluginInitializeJob</a></li>
            
                <li><a href="../classes/PluginInstallJob.html">PluginInstallJob</a></li>
            
                <li><a href="../classes/PluginJobRunner.html">PluginJobRunner</a></li>
            
                <li><a href="../classes/PluginPublicContentController.html">PluginPublicContentController</a></li>
            
                <li><a href="../classes/PluginService.html">PluginService</a></li>
            
                <li><a href="../classes/PluginSettingsFormController.html">PluginSettingsFormController</a></li>
            
                <li><a href="../classes/PluginUninstallJob.html">PluginUninstallJob</a></li>
            
                <li><a href="../classes/ReadOnlySimpleLayeredService.html">ReadOnlySimpleLayeredService</a></li>
            
                <li><a href="../classes/RedisCommandBroker.html">RedisCommandBroker</a></li>
            
                <li><a href="../classes/RedisRegistrationProvider.html">RedisRegistrationProvider</a></li>
            
                <li><a href="../classes/RedisSessionStore.html">RedisSessionStore</a></li>
            
                <li><a href="../classes/RequestHandler.html">RequestHandler</a></li>
            
                <li><a href="../classes/SecurityService.html">SecurityService</a></li>
            
                <li><a href="../classes/ServerRegistration.html">ServerRegistration</a></li>
            
                <li><a href="../classes/SessionHandler.html">SessionHandler</a></li>
            
                <li><a href="../classes/SimpleLayeredService.html">SimpleLayeredService</a></li>
            
                <li><a href="../classes/SortObjects.html">SortObjects</a></li>
            
                <li><a href="../classes/SortObjectsActionController.html">SortObjectsActionController</a></li>
            
                <li><a href="../classes/TemplateEntityService.html">TemplateEntityService</a></li>
            
                <li><a href="../classes/TemplateService.html">TemplateService</a></li>
            
                <li><a href="../classes/TemplateValue.html">TemplateValue</a></li>
            
                <li><a href="../classes/TopMenuService.html">TopMenuService</a></li>
            
                <li><a href="../classes/UrlApiController.html">UrlApiController</a></li>
            
                <li><a href="../classes/UrlService.html">UrlService</a></li>
            
                <li><a href="../classes/UserService.html">UserService</a></li>
            
                <li><a href="../classes/Util.html">Util</a></li>
            
                <li><a href="../classes/ValidationService.html">ValidationService</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="../modules/Admin.html">Admin</a></li>
            
                <li><a href="../modules/Database.html">Database</a></li>
            
                <li><a href="../modules/Entities.html">Entities</a></li>
            
                <li><a href="../modules/ErrorSuccess.html">ErrorSuccess</a></li>
            
                <li><a href="../modules/Model.html">Model</a></li>
            
                <li><a href="../modules/Security.html">Security</a></li>
            
                <li><a href="../modules/Services.html">Services</a></li>
            
                <li><a href="../modules/Session.html">Session</a></li>
            
                <li><a href="../modules/Storage.html">Storage</a></li>
            
                <li><a href="../modules/Theme.html">Theme</a></li>
            
                <li><a href="../modules/Validation.html">Validation</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: include\http\request_handler.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/*
    Copyright (C) 2014  PencilBlue, LLC

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
*/

/**
 * Responsible for processing a single req by delegating it to the correct controllers
 * @class RequestHandler
 * @constructor
 * @param {Server} server The http server that the request came in on
 * @param {Request} req The incoming request
 * @param {Response} resp The outgoing response
 */
function RequestHandler(server, req, resp){
	this.startTime = (new Date()).getTime();
	this.server    = server;
	this.req       = req;
	this.resp      = resp;
	this.url       = url.parse(req.url, true);
}

/**
 * A mapping that provides the interface type to parse the body based on the 
 * route specification
 * @private
 * @static
 * @readonly
 * @property BODY_PARSER_MAP
 * @type {Object}
 */
var BODY_PARSER_MAP = {
    &#x27;application/json&#x27;: pb.JsonBodyParser,
    &#x27;application/x-www-form-urlencoded&#x27;: pb.FormBodyParser,
    &#x27;multipart/form-data&#x27;: pb.FormBodyParser
};

/**
 * The fallback theme (pencilblue)
 * @static
 * @property DEFAULT_THEME
 * @type {String}
 */
RequestHandler.DEFAULT_THEME = &#x27;pencilblue&#x27;;

/**
 * The internal storage of routes after they are validated and processed.
 * @private
 * @static
 * @property storage
 * @type {Array}
 */
RequestHandler.storage = [];
RequestHandler.index   = {};

/**
 * The list of routes provided by the pencilblue plugin.  These routes are 
 * loaded first to ensure defaults are in place before other plugins are 
 * initialized.  In the future this will change so that all plugins are treated 
 * equally.
 * @private
 * @static
 * @property CORE_ROUTES
 * @type {Array}
 */
RequestHandler.CORE_ROUTES = require(path.join(DOCUMENT_ROOT, &#x27;/plugins/pencilblue/include/routes.js&#x27;));

/**
 * Initializes the request handler prototype by registering the core routes for
 * the system.  This should only be called once at startup.
 * @static
 * @method init
 */
RequestHandler.init = function(){

	//iterate core routes adding them
	pb.log.debug(&#x27;RequestHandler: Registering System Routes&#x27;);
	for (var i = 0; i &lt; RequestHandler.CORE_ROUTES.length; i++) {
		var descriptor = RequestHandler.CORE_ROUTES[i];

		//register the route
		RequestHandler.registerRoute(descriptor, RequestHandler.DEFAULT_THEME);
	}
};

/**
 * Generates the controller callback object that will trigger the redirect
 * header to be sent back as part of the response.
 * @static
 * @method generateRedirect
 * @param {String} location The fully qualified or relative URL to be redirected to
 * @return {Object} The object for the controller to call back with.
 */
RequestHandler.generateRedirect = function (location) {
	return {
		redirect: location
	};
};

/**
 * Validates a route descriptor.  The specified object must have a &quot;controller&quot;
 * property that points to a valid file and the &quot;path&quot; property must specify a
 * valid URL path structure.
 * @static
 * @method isValidRoute
 * @param {Object} descriptor The object to validate
 * @param {String} descriptor.controller The file path to the controller file
 * @param {String} descriptor.path The URL path
 */
RequestHandler.isValidRoute = function(descriptor) {
	return fs.existsSync(descriptor.controller) &amp;&amp;
		   typeof descriptor.path != &#x27;undefined&#x27;;
};

/**
 * Unregisters all routes associated with a theme
 * @static
 * @method unregisterThemeRoutes
 * @param {String} theme The plugin/theme uid
 * @return {Integer} The number of routes removed
 */
RequestHandler.unregisterThemeRoutes = function(theme) {

	var routesRemoved = 0;
	for (var i = 0; i &lt; RequestHandler.storage.length; i++) {
		var path   = RequestHandler.storage[i].path;
		var result = RequestHandler.unregisterRoute(path, theme);
		if (result) {
			routesRemoved++;
		}
	}
	return routesRemoved;
};

/**
 * Removes a route based on a URL path and theme UID
 * @static
 * @method unregisterRoute
 * @param {String} The URL path
 * @param {String} The theme that owns the route
 * @return {Boolean} TRUE if the route was found and removed, FALSE if not
 */
RequestHandler.unregisterRoute = function(path, theme) {

	//get the pattern to check for
	var pattern    = null;
	var patternObj = RequestHandler.getRoutePattern(path);
	if (patternObj) {
		pattern = patternObj.pattern;
	}
	else {//invalid path provided
		return false;
	}

	//check if that pattern is registered for any theme
	if (RequestHandler.index[pattern] === undefined) {
		return false;
	}

	//check for theme
	var descriptor = RequestHandler.storage[RequestHandler.index[pattern]];
	if (!descriptor.themes[theme]) {
		return false;
	}

	//remove from service
	delete descriptor.themes[theme];
	return true;
};

/**
 * Registers a route
 * @static
 * @method registerRoute
 * @param {Object} descriptor The route descriptor
 * @param {String} [descriptor.method=&#x27;ALL&#x27;] The HTTP method associated with
 * the route
 * @param {String} descriptor.path The URL path for the route.  The route
 * supports wild cards a well as path variables (/get/:id)
 * @param {String} descriptor.controller The file path to the controller to
 * execute when the path is matched to an incoming request.
 * @param {Integer} [descriptor.access_level=0] Use global constants:
 * ACCESS_USER,ACCESS_WRITER,ACCESS_EDITOR,ACCESS_MANAGING_EDITOR,ACCESS_ADMINISTRATOR
 * @param {Boolean} [descriptor.setup_required=true] If true the system must have gone
 * through the setup process in order to pass validation
 * @param {Boolean} [descriptor.auth_required=false] If true, the user making the
 * request must have successfully authenticated against the system.
 * @request {String} [descriptor.content_type=&#x27;text/html&#x27;] The content type header sent with the response
 * @param {String} theme The plugin/theme UID
 * @return {Boolean} TRUE if the route was registered, FALSE if not
 */
RequestHandler.registerRoute = function(descriptor, theme){
	//validate route
	if (!RequestHandler.isValidRoute(descriptor)) {
		pb.log.error(&quot;Route Validation Failed for: &quot;+JSON.stringify(descriptor));
		return false;
	}

	//standardize http method (if exists) to upper case
	if (descriptor.method) {
		descriptor.method = descriptor.method.toUpperCase();
	}
    else {
        descriptor.method = &#x27;ALL&#x27;
    }

	//get pattern and path variables
	var patternObj = RequestHandler.getRoutePattern(descriptor.path);
	var pathVars   = patternObj.pathVars;
	var pattern    = patternObj.pattern;

	//insert it
	var routeDescriptor = null;
	if (RequestHandler.index[pattern] !== undefined) {

		//exists so find it
		for (var i = 0; i &lt; RequestHandler.storage.length; i++) {
			var route = RequestHandler.storage[i];
			if (route.pattern == pattern) {
				routeDescriptor = route;
				break;
			}
		}
	}
	else{//does not exist so create it
		routeDescriptor = {
			path: patternObj.path,
			pattern: pattern,
			path_vars: pathVars,
			expression: new RegExp(pattern),
            themes: {}
		};

		//set them in storage
		RequestHandler.index[pattern] = RequestHandler.storage.length;
		RequestHandler.storage.push(routeDescriptor);
	}

	//set the descriptor for the theme and load the controller type
    if (!routeDescriptor.themes[theme]) {
        routeDescriptor.themes[theme] = {};
    }
	routeDescriptor.themes[theme][descriptor.method]            = descriptor;
	routeDescriptor.themes[theme][descriptor.method].controller = require(descriptor.controller);

	pb.log.debug(&quot;RequestHandler: Registered Route - Theme [%s] Path [%s][%s] Pattern [%s]&quot;, theme, descriptor.method, descriptor.path, pattern);
	return true;
};

/**
 * Generates a regular expression based on the specified path.  In addition the
 * algorithm extracts any path variables that are included in the path.  Paths
 * can include two types of wild cards.  The traditional glob pattern style of
 * &quot;/some/api/*&quot; can be used as well as path variables (&quot;/some/api/:action&quot;).
 * The path variables will be passed to the controllers.
 * @static
 * @method getRoutePattern
 * @param {String} The URL path
 * @return {Object|null} An object containing three properties: The specified
 * &quot;path&quot;. The generated regular expression &quot;pattern&quot; as a string. Lastly, a
 * hash of the path variables and their position in the path coorelating to its
 * depth in the path.
 */
RequestHandler.getRoutePattern = function(path) {
	if (!path) {
		return null;
	}

	//clean up path
	if (path.indexOf(&#x27;/&#x27;) == 0) {
		path = path.substring(1);
	}
	if (path.lastIndexOf(&#x27;/&#x27;) == path.length - 1) {
		path = path.substring(0, path.length - 1);
	}

	//construct the pattern &amp; extract path variables
	var pathVars = {};
	var pattern = &#x27;^&#x27;;
	var pathPieces = path.split(&#x27;/&#x27;);
	for (var i = 0; i &lt; pathPieces.length; i++) {
		var piece = pathPieces[i];

		if (piece.indexOf(&#x27;:&#x27;) == 0) {
			var fieldName = piece.substring(1);
			pathVars[fieldName] = i + 1;
			pattern += &#x27;/[A-Za-z0-9_\-]+&#x27;;
		}
		else {
			if (piece.indexOf(&#x27;*&#x27;) &gt;= 0) {
				piece = piece.replace(/\*/g, &#x27;.*&#x27;);
			}
			pattern += &#x27;/&#x27;+piece;
		}
	}
	pattern += &#x27;[/]{0,1}$&#x27;;

	return {
		path: path,
		pattern: pattern,
		pathVars: pathVars
	};
};

/**
 * Processes a request:
 * &lt;ol&gt;
 * 	&lt;li&gt;Initialize localization&lt;/li&gt;
 * 	&lt;li&gt;if Public Route:
 * 		&lt;ol&gt;
 * 			&lt;li&gt;If Valid Content
 * 				&lt;ol&gt;&lt;li&gt;Serve Public Content&lt;/li&gt;&lt;/ol&gt;
 * 			&lt;/li&gt;
 * 			&lt;li&gt;Else Serve 404&lt;/li&gt;
 * 		&lt;/ol&gt;
 * 	&lt;/li&gt;
 * 	&lt;li&gt;Else Parse Cookies&lt;/li&gt;
 * 	&lt;li&gt;Open/Create a session&lt;/li&gt;
 * 	&lt;li&gt;Get Route&lt;/li&gt;
 * &lt;/ol&gt;
 * @method handleRequest
 */
RequestHandler.prototype.handleRequest = function(){

	//get locale preference
	this.localizationService = new pb.Localization(this.req);

	//fist things first check for public resource
	if (RequestHandler.isPublicRoute(this.url.pathname)) {
		this.servePublicContent();
		return;
	}

	//check for session cookie
	var cookies = RequestHandler.parseCookies(this.req);
	this.req.headers[pb.SessionHandler.COOKIE_HEADER] = cookies;

    //open session
	var self = this;
    pb.session.open(this.req, function(err, session){

    	//set the session id when no session has started or the current one has
    	//expired.
    	var sc = Object.keys(cookies).length == 0;
    	var se = !sc &amp;&amp; cookies.session_id != session.uid;
    	self.setSessionCookie =  sc || se;
    	if (pb.log.isSilly()) {
    		pb.log.silly(&quot;RequestHandler: Session ID [&quot;+session.uid+&quot;] Cookie SID [&quot;+cookies.session_id+&quot;] Created [&quot;+sc+&quot;] Expired [&quot;+se+&quot;]&quot;);
    	}

    	//continue processing
    	self.onSessionRetrieved(err, session);
    });
};

/**
 * Serves up public content from an absolute file path
 * @method servePublicContent
 * @param {String} absolutePath An absolute file path to the resource
 */
RequestHandler.prototype.servePublicContent = function(absolutePath) {

	//check for provided path, then default if necessary
    if (absolutePath === undefined) {
		absolutePath = path.join(DOCUMENT_ROOT, &#x27;public&#x27;, this.url.pathname);
	}

	var self = this;
	fs.readFile(absolutePath, function(err, content){
		if (err) {
			self.serve404();
			return;
		}

		//build response structure
		var data = {
			content: content
		};

		//guess at content-type
		var mime = RequestHandler.getMimeFromPath(absolutePath);
        if (mime) {
            data.content_type = mime;
        }

		//send response
		self.writeResponse(data);
	});
};

/**
 * Attempts to derive the MIME type for a resource path based on the extension 
 * of the path.
 * @static
 * @method getMimeFromPath
 * @param {resourcePath} The file path to a resource
 * @return {String} The MIME type or NULL if could not be derived.
 */
RequestHandler.getMimeFromPath = function(resourcePath) {
    var map = {
        js: &#x27;text/javascript&#x27;,
        css: &#x27;text/css&#x27;,
        png: &#x27;image/png&#x27;,
        svg: &#x27;image/svg+xml&#x27;,
        jpg: &#x27;image/jpeg&#x27;,
        gif: &#x27;image/gif&#x27;,
        webp: &#x27;image/webp&#x27;,
        ico: &#x27;image/vnd.microsoft.icon&#x27;,
        tff: &#x27;application/octet-stream&#x27;,
        eot: &#x27;application/vnd.ms-fontobject&#x27;,
        woff: &#x27;application/x-font-woff&#x27;,
        html: &#x27;text/html&#x27;
    };
    var index = resourcePath.lastIndexOf(&#x27;.&#x27;);
    if (index &gt;= 0) {
        return map[resourcePath.substring(index + 1)];
    }
    return undefined;
};

/**
 * Determines if the path is mapped to static resources
 * @static
 * @method isPublicRoute
 * @param {String} path URL path to a resource
 * @return {Boolean} TRUE if mapped to a public resource directory, FALSE if not
 */
RequestHandler.isPublicRoute = function(path){
	var publicRoutes = [&#x27;/js/&#x27;, &#x27;/css/&#x27;, &#x27;/fonts/&#x27;, &#x27;/img/&#x27;, &#x27;/localization/&#x27;, &#x27;/favicon.ico&#x27;, &#x27;/docs/&#x27;, &#x27;/bower_components/&#x27;];
	for (var i = 0; i &lt; publicRoutes.length; i++) {
		if (path.indexOf(publicRoutes[i]) == 0) {
			return true;
		}
	}
	return false;
};

/**
 * Serves up a 404 page when the path specified by the incoming request does 
 * not exist. This function &lt;b&gt;WILL&lt;/b&gt; close the connection.
 * @method serve404
 */
RequestHandler.prototype.serve404 = function() {

	var NotFound  = require(path.join(DOCUMENT_ROOT, &#x27;plugins&#x27;, &#x27;pencilblue&#x27;, &#x27;/controllers/error/404.js&#x27;));
	var cInstance = new NotFound();
	this.doRender({}, cInstance, {});

	if (pb.log.isSilly()) {
		pb.log.silly(&quot;RequestHandler: No Route Found, Sending 404 for URL=&quot;+this.url.href);
	}
};

/**
 * Serves up an error page.  The page is responsible for displaying an error page
 * TODO Church this up a bit.  Make it a template and controller like 404.
 * TODO install an encoder entity since node prints out function names in angle brackets
 * @method serveError
 * @param {Error} err The failure that was generated by the executed controller
 * @return {Boolean} TRUE when the error is rendered, FALSE if the request had already been handled
 */
RequestHandler.prototype.serveError = function(err) {
    if (this.resp.headerSent) {
        return false;
    }
    
	var data = {
		content: &#x27;&lt;html&gt;&lt;body&gt;&lt;h2&gt;Whoops! Something unexpected happened.&lt;/h2&gt;&lt;br/&gt;&lt;pre&gt;&#x27;+(err ? err.stack : err)+&#x27;&lt;/pre&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,
		content_type: &#x27;text/html&#x27;,
		code: 500
	};
	this.onRenderComplete(data);
    return true;
};

/**
 * Called when the session has been retrieved.  Responsible for checking the 
 * active theme.  It then retrieves the route object and passes it off to onThemeRetrieved.
 * @method onSessionRetrieved
 * @param {Error} err Any error that occurred while retrieving the session
 * @param {Object} session The session for the requesting entity
 */
RequestHandler.prototype.onSessionRetrieved = function(err, session) {
	if (err) {
		this.onErrorOccurred(err);
		return;
	}

	//set the session
	this.session = session;

	//find the controller to hand off to
	var route = this.getRoute(this.url.pathname);
	if (route == null) {
		this.serve404();
		return;
	}
	this.route = route;

	//get active theme
	var self = this;
	pb.settings.get(&#x27;active_theme&#x27;, function(err, activeTheme){
		if (!activeTheme) {
			pb.log.warn(&quot;RequestHandler: The active theme is not set.  Defaulting to &#x27;%s&#x27;&quot;, RequestHandler.DEFAULT_THEME);
			activeTheme = RequestHandler.DEFAULT_THEME;
		}
		self.onThemeRetrieved(activeTheme, route);
	});
};

/**
 * Compares the path against the registered routes&#x27;s to lookup the route object.
 * @method getRoute
 * @path {String} path The URL path for the incoming request
 * @return {Object} The route object or NULL if the path does not match any route
 */
RequestHandler.prototype.getRoute = function(path) {

	var route = null;
	for (var i = 0; i &lt; RequestHandler.storage.length; i++) {

		var curr   = RequestHandler.storage[i];
		var result = curr.expression.test(path);

		if (pb.log.isSilly()) {
			pb.log.silly(&#x27;RequestHandler: Comparing Path [%s] to Pattern [%s] Result [%s]&#x27;, path, curr.pattern, result);
		}
		if (result) {
			route = curr;
			break;
		}
	}
	return route;
};

/**
 * Determines if the route supports the given HTTP method
 * @static
 * @method routeSupportsMethod
 * @param {Object} themeRoutes The route object that contains the specifics for 
 * the theme variation of the route.
 * @param {String} method HTTP method
 */
RequestHandler.routeSupportsMethod = function(themeRoutes, method) {
    method = method.toUpperCase();
    return themeRoutes[method] !== undefined;
};

/**
 * Determines if a route supports a particular theme and HTTP method
 * @static
 * @method routeSupportsTheme
 * @param {Object} route
 * @param {String} theme The theme
 * @param {String} method HTTP method
 * @return {Boolean}
 */
RequestHandler.routeSupportsTheme = function(route, theme, method) {
    return route.themes[theme] !== undefined &amp;&amp; RequestHandler.routeSupportsMethod(route.themes[theme], method);
};

/**
 * Determines the theme that will be executed for the route.
 * The themes will be prioritized as: active theme, pencilblue, followed by 
 * iterating over all other inherited themes.
 * @method getRouteTheme
 * @param {String} activeTheme
 * @param {Object} route
 * @return {Object} An object with two properties: theme and method
 */
RequestHandler.prototype.getRouteTheme = function(activeTheme, route) {
    var obj = {theme: null, method: null};

    var methods = [this.req.method, &#x27;ALL&#x27;];
    for (var i = 0; i &lt; methods.length; i++) {

        //check for themed route
        var themesToCheck = [activeTheme, RequestHandler.DEFAULT_THEME];
        pb.utils.arrayPushAll(Object.keys(route.themes), themesToCheck);
        for (var j = 0; j &lt; themesToCheck.length; j++) {

            //see if theme supports method and provides support
            if (RequestHandler.routeSupportsTheme(route, themesToCheck[j], methods[i])) {
                obj.theme  = themesToCheck[j];
                obj.method = methods[i];
                return obj;
            }
        }
    }
    return obj;
}

/**
 * 
 * @method onThemeRetrieved
 * @param {String} activeTheme
 * @param {Object} route
 */
RequestHandler.prototype.onThemeRetrieved = function(activeTheme, route) {
	var self = this;

	//check for unregistered route for theme
	var rt = this.getRouteTheme(activeTheme, route);

	if (pb.log.isSilly()) {
		pb.log.silly(&quot;RequestHandler: Settling on theme [%s] and method [%s] for URL=[%s:%s]&quot;, rt.theme, rt.method, this.req.method, this.url.href);
	}

	//sanity check
	if (rt.theme === null || rt.method === null) {
		this.serve404();
		return;
	}

	//do security checks
	this.checkSecurity(rt.theme, rt.method, function(err, result) {
		if (pb.log.isSilly()) {
			pb.log.silly(&quot;RequestHandler: Security Result=[%s]&quot;, result.success);
			for (var key in result.results) {
				pb.log.silly(&quot;RequestHandler:&quot;+key+&#x27;: &#x27;+JSON.stringify(result.results[key]));
			}
		}
		//all good
		if (result.success) {
			self.onSecurityChecksPassed(rt.theme, rt.method, route);
			return;
		}

		//handle failures through bypassing other processing and doing output
		self.onRenderComplete(err);
	});
};

/**
 *
 * @method onSecurityChecksPassed
 * @param {String} activeTheme
 * @param {String} method
 * @param {Object} route
 */
RequestHandler.prototype.onSecurityChecksPassed = function(activeTheme, method, route) {

	//extract path variables
	var pathVars = {};
	var pathParts = this.url.pathname.split(&#x27;/&#x27;);
	for (var field in route.path_vars) {
		pathVars[field] = pathParts[route.path_vars[field]];
	}

	//execute controller
	var ControllerType  = route.themes[activeTheme][method].controller;
	var cInstance       = new ControllerType();
	this.doRender(pathVars, cInstance, route.themes[activeTheme][method]);
};

/**
 * Begins the rendering process by initializing the controller.  This is done 
 * by gathering all initialization parameters and calling the controller&#x27;s 
 * &quot;init&quot; function.
 * @method doRender
 * @param {Object} pathVars The URL path&#x27;s variables
 * @param {BaseController} cInstance An instance of the controller to be executed
 * @param {Object} themeRoute
 */
RequestHandler.prototype.doRender = function(pathVars, cInstance, themeRoute) {
	var self  = this;
    
    //attempt to parse body
    this.parseBody(themeRoute.request_body, function(err, body) {
        if (util.isError(err)) {
            return self.serveError(err);
        }
        
        var props = {
            request_handler: self,
            request: self.req,
            response: self.resp,
            session: self.session,
            localization_service: self.localizationService,
            path_vars: pathVars,
            query: self.url.query,
            body: body
        };
        cInstance.init(props, function(){
            self.onControllerInitialized(cInstance, themeRoute);
        });
    });
};

/**
 * Parses the incoming request body when the body type specified matches one of 
 * those explicitly allowed by the rotue.
 * @method parseBody
 * @param {Array} mimes An array of allowed MIME strings.  
 * @param {Function} cb A callback that takes 2 parameters: An Error, if 
 * occurred and the parsed body.  The parsed value is often an object but the 
 * value is dependent on the parser selected by the content type.
 */ 
RequestHandler.prototype.parseBody = function(mimes, cb) {
    
    //we don&#x27;t force a mime.  Controllers have the ability to handle this 
    //themselves.
    if (!util.isArray(mimes)) {
        return cb(null, null);
    }

    //verify that the content type is acceptable
    var contentType = this.req.headers[&#x27;content-type&#x27;];
    if (contentType) {
        
        //we split on &#x27;;&#x27; to check for multipart encoding since it specifies a 
        //boundary
        contentType = contentType.split(&#x27;;&#x27;)[0];
        if (mimes.indexOf(contentType) === -1) {
            //a type was specified but its not accepted by the controller
            //TODO return HTTP 415
            return cb(null, null);
        }
    }
    
    //create the parser
    var BodyParser = BODY_PARSER_MAP[contentType];
    if (!BodyParser) {
        pb.log.silly(&#x27;RequestHandler: no handler was found to parse the body type [%s]&#x27;, contentType);
        return cb(null, null);
    }
    
    //execute the parsing
    var self = this;
    var d = domain.create();
    d.on(&#x27;error&#x27;, cb);
    d.run(function() {
        process.nextTick(function() {
            
            //initialize the parser and parse content
            var parser = new BodyParser();
            parser.parse(self.req, cb);
        });
    });
};

/**
 *
 * @method onControllerInitialized
 * @param {BaseController} controller
 */
RequestHandler.prototype.onControllerInitialized = function(controller, themeRoute) {
	var self = this;
    var d = domain.create();
    d.add(controller);
    d.run(function() {
        process.nextTick(function() {
            controller[themeRoute.handler ? themeRoute.handler : &#x27;render&#x27;](function(result){
                self.onRenderComplete(result);
            });
        });
	});
    d.on(&#x27;error&#x27;, function(err) {
        pb.log.error(&quot;RequestHandler: An error occurred during controller execution. URL=[%s:%s] ROUTE=%s\n%s&quot;, self.req.method, self.req.url, JSON.stringify(self.route), err.stack);
        self.serveError(err);
    });
};

/**
 *
 * @method onRenderComplete
 * @param {Object} data
 */
RequestHandler.prototype.onRenderComplete = function(data){

	//set cookie
    var cookies = new Cookies(this.req, this.resp);
    if (this.setSessionCookie) {
    	try{
    		cookies.set(pb.SessionHandler.COOKIE_NAME, this.session.uid, pb.SessionHandler.getSessionCookie(this.session));
    	}
    	catch(e){
    		pb.log.error(&#x27;RequestHandler: %s&#x27;, e.stack);
    	}
    }

	//do any necessary redirects
	var doRedirect = typeof data.redirect != &quot;undefined&quot;;
	if(doRedirect) {
        this.doRedirect(data.redirect);
    }
	else {
		//output data here
		this.writeResponse(data);
	}

	//calculate response time
	if (pb.log.isDebug()) {
		pb.log.debug(&quot;Response Time: &quot;+(new Date().getTime() - this.startTime)+
				&quot;ms URL=[&quot;+this.req.method+&#x27;]&#x27;+
				this.req.url+(doRedirect ? &#x27; Redirect=&#x27;+data.redirect : &#x27;&#x27;) +
				(data.code == undefined ? &#x27;&#x27; : &#x27; CODE=&#x27;+data.code));
	}

	//close session after data sent
	//public content doesn&#x27;t require a session so in order to not error out we
	//check if the session exists first.
	if (this.session) {
		pb.session.close(this.session, function(err, result) {
			//TODO handle any errors
		});
	}
};

/**
 *
 * @method writeResponse
 * @param {Object} data
 */
RequestHandler.prototype.writeResponse = function(data){

    //infer a response code when not provided
    if(typeof data.code === &#x27;undefined&#x27;){
        data.code = 200;
    }

    // If a response code other than 200 is provided, force that code into the head
    var contentType = &#x27;text/html&#x27;;
    if (typeof data.content_type !== &#x27;undefined&#x27;) {
    	contentType = data.content_type;
    }
    else if (this.themeRoute &amp;&amp; this.themeRoute.content_type != undefined) {
    	contentType = this.themeRoute.content_type;
    }

    //send response
    //the catch allows us to prevent any plugins that callback trwice from
    //screwing us over due to the attempt to write headers twice.
    try {
    	//set any custom headers
    	if (pb.utils.isObject(data.headers)) {
    		for(var header in data.headers) {
    			this.resp.setHeader(header, data.headers[header]);
    		}
    	}
        if (pb.config.server.x_powered_by) {
            this.resp.setHeader(&#x27;x-powered-by&#x27;, pb.config.server.x_powered_by);
        }
    	this.resp.setHeader(&#x27;content-type&#x27;, contentType);
    	this.resp.writeHead(data.code);
    	this.resp.end(data.content);
    }
    catch(e) {
    	pb.log.error(&#x27;RequestHandler: &#x27;+e.stack);
    }
};

/**
 * Creates a cookie string
 * @method writeCookie
 * @param {Object} descriptor The pieces of the cookie that are to be included 
 * in the string.  These pieces are represented as key value pairs.  Each value 
 * will be serialized via its implicity &quot;toString&quot; function.
 * @param {String} [cookieStr=&#x27;&#x27;] The current cookie string if it exists
 * @return {String} The cookie represented as a string
 */
RequestHandler.prototype.writeCookie = function(descriptor, cookieStr){
	cookieStr = cookieStr ? cookieStr : &#x27;&#x27;;

	for(var key in descriptor) {
        cookieStr += key + &#x27;=&#x27; + descriptor[key]+&#x27;; &#x27;;
    }
	return cookieStr;
};

/**
 * Verifies that the incoming request meets all necessary security critiera
 * @method checkSecurity
 * @param {String} activeTheme
 * @param {String} method
 * @param {Function} cb
 */
RequestHandler.prototype.checkSecurity = function(activeTheme, method, cb){
	var self        = this;
	this.themeRoute = this.route.themes[activeTheme][method];

	//verify if setup is needed
	var checkSystemSetup = function(callback) {
		var result = {success: true};
		if (self.themeRoute.setup_required == undefined || self.themeRoute.setup_required == true) {
			pb.settings.get(&#x27;system_initialized&#x27;, function(err, isSetup){

				//verify system init
				if (!isSetup) {
					result.success = false;
					result.redirect = &#x27;/setup&#x27;;
					callback(result, result);
					return;
				}
				callback(null, result);
			});
		}
		else {
			callback(null, result);
		}
	};

	var checkRequiresAuth = function(callback) {

		var result = {success: true};
		if (self.themeRoute.auth_required == true) {

			if (self.session.authentication.user_id == null || self.session.authentication.user_id == undefined) {
				result.success  = false;
				result.redirect = RequestHandler.isAdminURL(self.url.href) ? &#x27;/admin/login&#x27; : &#x27;/user/login&#x27;;
				self.session.on_login = self.req.method.toLowerCase() === &#x27;get&#x27; ? self.url.href : pb.UrlService.urlJoin(pb.config.siteRoot, &#x27;/admin&#x27;);
				callback(result, result);
				return;
			}
			callback(null, result);
		}
		else{
			callback(null, result);
		}
	};

	var checkAdminLevel = function(callback) {

		var result = {success: true};
		if (self.themeRoute.access_level !== undefined) {

			if (self.session.authentication.admin_level &lt; self.themeRoute.access_level) {
				result.success = false;
				result.content = &#x27;403 Forbidden&#x27;;
				result.code    = 403;
				callback(result, result);
				return;
			}
			callback(null, result);
		}
		else{
			callback(null, result);
		}
	};

	var checkPermissions = function(callback) {

		var result   = {success: true};
		var reqPerms = self.themeRoute.permissions;
		var auth     = self.session.authentication;
		if (auth &amp;&amp; auth.user &amp;&amp; auth.access_level !== ACCESS_ADMINISTRATOR &amp;&amp; auth.user.permissisions &amp;&amp; util.isArray(reqPerms)) {

			var permMap = self.session.authentication.user.permissions;
			for(var i = 0; i &lt; reqPerms.length; i++) {

				if (!permMap[reqPerms[i]]) {
					result.success = false;
					result.content = &#x27;403 Forbidden&#x27;;
					result.code    = 403;
					callback(result, result);
					return;
				}
			}
			callback(null, result);
		}
		else{
			callback(null, result);
		}
	};

	var tasks = {
		checkSystemSetup: checkSystemSetup,
        checkRequiresAuth: checkRequiresAuth,
        checkAdminLevel: checkAdminLevel,
        checkPermissions: checkPermissions
	};
	async.series(tasks, function(err, results){
		if (err) {
			cb(err, {success: false, results: results});
			return;
		}

		cb(null, {success: true, results: results});
	});
};

/**
 *
 * @method doRedirect
 * @param {String} location
 */
RequestHandler.prototype.doRedirect = function(location) {
	this.resp.statusCode = 302;
    this.resp.setHeader(&quot;Location&quot;, location);
    this.resp.end();
};

/**
 * 
 * @method onErrorOccurred
 * @param {Error} err
 */
RequestHandler.prototype.onErrorOccurred = function(err){
	var error = new PBError(&quot;Failed to open a session&quot;, 500);
	error.setSource(err);
	throw error;
};

/**
 *
 * @static
 * @method parseCookies
 * @param {Request} req
 * @return {Object}
 */
RequestHandler.parseCookies = function(req){

	var parsedCookies = {};
	if (req.headers.cookie) {

        var cookieParameters = req.headers.cookie.split(&#x27;;&#x27;);
        for(var i = 0; i &lt; cookieParameters.length; i++)  {

        	var keyVal = cookieParameters[i].split(&#x27;=&#x27;);
            parsedCookies[keyVal[0]] = keyVal[1];
        }
	}
    return parsedCookies;
};

/**
 *
 * @static
 * @method urlExists
 * @param {String} url
 * @param {
 */
RequestHandler.urlExists = function(url, id, cb) {
	var dao = new pb.DAO();
	var getTask = function(collection) {
		return function (callback) {
			var where = {url: url};
			if (id) {
				where[pb.DAO.getIdField()] = pb.DAO.getNotIDField(id);
			}
			dao.count(collection, where, function(err, count) {
                if(util.isError(err) || count &gt; 0) {
                    callback(true, count);
                }
                else {
                	callback(null, count);
                }
			});
		};
	};
	async.series([getTask(&#x27;article&#x27;), getTask(&#x27;page&#x27;)], function(err, results){
		cb(err, err != null);
	});
};

/**
 * 
 * @static
 * @method isAdminURL
 * @param {String} url
 */
RequestHandler.isAdminURL = function(url) {
	if (url != null) {

		var index = url.indexOf(&#x27;/&#x27;);
		if (index == 0 &amp;&amp; url.length &gt; 0) {
			url = url.substring(1);
		}

		var pieces = url.split(&#x27;/&#x27;);
		return pieces.length &gt; 0 &amp;&amp; pieces[0].indexOf(&#x27;admin&#x27;) == 0;
	}
	return false;
};

/**
 *
 * @static
 * @method isSystemSafeURL
 * @param {String} url
 * @param {String} id
 * @param {Function} cb
 */
RequestHandler.isSystemSafeURL = function(url, id, cb) {
	if (url == null || RequestHandler.isAdminURL(url)) {
		cb(null, false);
		return;
	}
	RequestHandler.urlExists(url, id, function(err, exists){
		cb(err, !exists);
	});
};

/**
 * Registers a body parser prototype for the specified mime
 * @static
 * @method registerBodyParser
 * @param {String} mime A non empty string representing the mime type that the prototype can parse
 * @param {Function} prototype A prototype that can have an instance created and parse the specified mime type
 * @return {Boolean} TRUE if the body parser was registered, FALSE if not
 */
RequestHandler.registerBodyParser = function(mime, protoype) {
    if (!pb.validation.isNonEmptyStr(mime) || !pb.utils.isFunction(prototype)) {
        return false;
    }
    
    //set the prototype handler
    BODY_PARSER_MAP[mime] = protoype;
    return true;
};

//exports
module.exports.RequestHandler = RequestHandler;

    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
